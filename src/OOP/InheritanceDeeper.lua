---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by galax.
--- DateTime: 6/9/2020 8:45 PM
---

Class = {x = 0, y = 0}

Class.__index = Class

function Class:new(x,y)
    local self = {}
    setmetatable(self, Class)
    self.x = x
    self.y = y
    return self
end

function Class:test()
    print(self.x, self.y)
end

-- 继承，子类
Main = {z = 0}
setmetatable(Main, Class)
Main.__index = Main

function Main:new(x,y,z)
    local self = {}
    -- 引用父类的constructor
    self = Class:new(x,y)
    setmetatable(self, Main)
    self.z = z
    return self
end

function Main:go()
    self.x = self.x + 1
end

function Main:test()
    print(self.x, self.y, self.z)
end

-- 创建一个子类
pointA = Main:new(10,20,30)
-- 原理：当访问父类元素x时，先查到 Main表中有无["x"]，如果没有；查找Main有无元表，如果有，查找元表中是否存在__index方法，如果存在，看看__index方法保存的是元表还是函数。
-- 在这个例子，__index方法是一个元表["x" = 10, "y" = 20]，所以就获取了["x"]值 10
print(pointA.x)

--[[ 在继承中，重要的是复写__index方法指向自己，和把子类metatable设为父类 --]]
